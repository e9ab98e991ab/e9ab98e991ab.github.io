<div class="detail lh2"><p>阅读以下关于分布式数据库缓存设计的叙述，在答题纸上回答问题1至问题3。<br/>【 说明 】<br/>某初创企业的主营业务是为用户提供高度个性化的商品订购业务，其业务系统支持PC端、手机App等多种访问方式。系统上线后受到用户普遍欢迎，在线用户数和订单数量迅速增长，原有的关系数据库服务器不能满足高速并发的业务要求。<br/>为了减轻数据库服务器的压力，该企业采用了分布式缓存系统，将应用系统经常使用的数据放置在内存，降低对数据库服务器的查询请求，提高了系统性能。在使用缓存系统的过程中，企业碰到了一系列技术问题。</p><br/><br/><p>【问题 1】（11 分）<br/>该系统使用过程中，由于同样的数据分别存在于数据库和缓存系统中，必然会造成数据同步或数据不一致性的问题。该企业团队为解决这个问题，提出了如下解决思路：<br/>应用程序读数据时，首先读缓存，当该数据不在缓存时，再读取数据库；应用程序写数据时，先写缓存，成功后再写数据库；或者先写数据库，再写缓存。<br/>王工认为该解决思路并未解决数据同步或数据不一致性的问题，请用100字以内的文字解释其原因 。<br/>王工给出了一种可以解决该问题的数据读写步骤如下 ：<br/>读数据操作的基本步骤 ：<br/>1.根据key读缓存；<br/>2.读取成功则直接返回；<br/>3.若key不在缓存中时，根据key（a）；<br/>4.读取成功后，（b）；<br/>5.成功返回 。<br/>写数据操作的基本步骤 ：<br/>1.根据key值写（c）；<br/>2.成功后（d）；<br/>3.成功返回。<br/>请填写完善上述步骤中（a）~（d）处的空白内容。<br/>【问题 2 】（8 分）<br/>缓存系统一般以key/value形式存储数据，在系统运维中发现，部分针对缓存的查询，未在缓存系统中找到对应的key，从而引发了大量对数据库服务器的查询请求，最严重时甚至导致了数据库服务器的宕机。<br/>经过运维人员的深入分析，发现存在两种情况：<br/>（1）用户请求的key值在系统中不存在时，会查询数据库系统，加大了数据库服务器的压力；<br/>（2）系统运行期间，发生了黑客攻击，以大量系统不存在的随机key发起了查询请求，从而导致了数据库服务器的宕机 。经过研究，研发团队决定，当在数据库中也未查找到该key时，在缓存系统中为key设置空值，防止对数据库服务器发起重复查询 。<br/>请用100字以内文字说明该设置空值方案存在的问题，并给出解决思路。<br/>【问题 3】（6 分）<br/>缓存系统中的key一般会存在有效期，超过有效期则key失效；有时也会根据LRU算法将某些key移出内存。当应用软件查询key时，如key失效或不在内存，会重新读取数据库，并更新缓存中的key。<br/>运维团队发现在某些情况下，若大量的key设置了相同的失效时间，导致缓存在同一时刻众多key同时失效，或者瞬间产生对缓存系统不存在key的大量访问，或者缓存系统重启等原因，都会造成数据库服务器请求瞬时爆量，引起大量缓存更新操作，导致整个系统性能急剧下降，进而造成整个系统崩溃。<br/>请用100字以内文字，给出解决该问题的两种不同思路。</p><br/><br/>答案<br/><p>【问题 1】<br/>存在双写不一致问题，在写数据时，可能存在缓存写成功，数据库写失败，或者反之，从而造成数据不一致。当多个请求发生时，也可能产生读写冲突的并发问题。<br/>（a）从数据库中读取数据或读数据库<br/>（b）更新缓存中key值或更新缓存<br/>（c）数据库<br/>（d）删除缓存key或使缓存key失效或更新缓存（key值）<br/>【问题 2】<br/>存在问题：不在系统中的key值是无限的，如果均设置key值为空，会造成内存资源的极大浪费，引起性能急剧下降。<br/>解决思路：查询缓存之前，对key值进行过滤，只允许系统中存在的key进行后续操作（例如采用key的bitmap 进行过滤）。<br/>【问题 3】<br/>思路 1：缓存失效后，通过加排它锁或者队列方式控制数据库写缓存的线程数量，使得缓存更新串行化；<br/>思路 2：给不同key设置随机或不同的失效时间，使失效时间的分布尽量均匀；<br/>思路 3：设置两级或多级缓存，避免访问数据库服务器。<br/><br/></p><br/><br/>试题分析<br/><p>【问题1】<br/>在原有方案中，应用程序写数据时，先写缓存，成功后再写数据库；或者先写数据库，再写缓存。这里存在双写不一致问题。不管先写缓存还是数据库，都会存在一方写成功，另一方写失败的问题，从而造成数据不一致。当多个请求发生时，也可能产生读写冲突的并发问题。<br/>王工的解决思路是：读操作的顺序是，先读缓存，如果数据在缓存中，则直接返回，无须数据库操作；如果数据不在缓存，则读数据库，如成功，则更新缓存，如失败，则返回无此数据。<br/>读操作主要解决查询效率问题。写操作的顺序是先写数据库，如失败，则返回失败；如成功，则更新缓存。更新缓存可能的方式有：如缓存中无此key值，则在缓存中不作处理；如缓存中存在此key值，则删除key值或使该key值失效。写操作的顺序主要防止数据库写操作失败，缓存更新为内存操作，失败的概率很小。同时删除key或使key失效，则在下一次查询该key值时，会发起数据库读操作，并同步更新缓存中的key值，从而最大程度上避免双写不一致问题。<br/>【问题2】<br/>该方法主要的思路是为系统中不存在的key，在缓存中增加该key，并设置key对应的值为空值，从而防止下次发起对数据库的查询操作。<br/>该方法存在的问题是，不在系统中的key值是无限的，如果均设置key值为空，会造成内存资源的极大浪费，引起性能急剧下降。<br/>解决思路是对于系统中存在的key值，在查询前进行过滤，只允许系统中存在的key进行后续操作，因为一般情况下，系统中的key是有限的，或者是符合某种规则的。例如可以采用key的bitmap进行过滤，降低过滤的消耗。<br/>【问题3】<br/>运维团队发现的大量缓存key值同时失效，从而导致整个系统性能急剧下降，进而造成整个系统崩溃，其主要的原因是key值失效，导致数据库服务器请求瞬时爆量，引起大量缓存更新操作，从而导致了系统性能急剧下降，系统崩溃。<br/>解决该问题的思路就是采取某种做法，使得缓存中同一时间不会出现大量的key值失效。<br/>具体的思路有：<br/>1.缓存失效后，大量的缓存更新操作进行排队，通过加排它锁、队列等方式控制同时进行缓存更新操作的数量，使得缓存更新串行化，降低更新频率。此方式效果不佳，并没有从根源上解决大量缓存key值同时失效的问题。<br/>2.在增加或更新缓存时，给不同key设置随机或不同的失效时间，使失效时间的分布尽量均匀，从根源上避免大量缓存key值同时失效。<br/>3.设置两级或多级缓存，避免访问数据库服务器。此方式也没有从根源上解决大量缓存key值同时失效的问题。 <br/></p><p></p></div>